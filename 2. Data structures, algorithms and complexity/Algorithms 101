Algorithms 101

In mathematics and computer science, an algorithm is a step-by step procedure for calculations. An Algorithm is an effective method expressed as a finite of well-defined instructions for calculating function.

Процедура описана стъпка по стъпка, какво трябва да се случи и в крайна сметка да се изкара някакъв резултат.

Има вход (масив, число, граф)
Има изход (число)

Алгоритмите най-често се описват в псевдо код.

Термина идва от muhammad al khwarizmi - https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi (създателя на алгоритъма за квадратни уравнения)

Алгоритмите са фундаментални за компютърните науки и за програмирането.

Описват по формален начин как се прави нещо.

Algorithm == sequence of operations (steps)

Познанието по алгоритми и СД е нещото по което се различват занаятчиите и професионалистите.

Algorithm thinking (mathematical thinking, logical thinking, engineering thinking)
- възможността да декомпозираме решнието на даден проблем в различни стъпки
Да се разбива проблема на части, да се спазва точно определена последователност.

Всеки алгоритъм има вход и изход.
Пример за Дийкстра - вход граф и начало и изход разстояние

Представяне на алгоритми чрез псевдо код или flowcharts (блок схема)

Фундаментални алгоритми в програмирането
========================================
- Сортиране и търсене - неща които ги има навсякъде
- Динамично програмиране - използва намерени решения и конструира нови на база на намерените
f(n) = f(n-1) + f(n-2)
Ако го смятаме с рекурсия, ще смятаме много пъти нещата, които не ни трябват.
Най дълга обща подредица се решава с динамично оптимиране.
Защо като търсим най-малко число не го сръвняваме с всички останали, а само с най-малко? (защото е тъпо)

- Алгоритми върху графи
  - Търсене в дълбочина и в ширина
- Комбинаторни алгоритми
  - Рекурсивни алгоритми
- Други
  - Greedy algorithms, computational geometry, randomized algorithms, genetic algorithms
Алгоритмите на Google може да разпознава котка по картинка?!
Алгоритми за voice recognition и за букви

Сложност на алгоритми
=====================
Защо трябва да анализираме алгоритми?
-----------
Мерим ресурси
- Изчисляване на процесорно време
- Колко рам заема
- Communication bandwidth

Колко време се изпълнява да ден алгоритм
-------------
- Колко примитивни операции ще се execute-нат (сложност на алгоритми)
- Важен е порядъка

Нещо на което входните му данни са n и сложността е n^2 изглежда ето така:
f(n) = n*n
Пример с масив от n елемента.
Ако масива е от 10 елемента то ще се извършат 100 операции.

Ако сложността е n, то ако има 10 елемента ще се извършат 10 операции.

Сложност на алгоритъм е на базата на входните параметри ни казва, колко операции ще има алгоритъма

Какво мерим?
=========
- CPU time, memory, steps, particular operations etc.

Time complexity
===============
Мерим 3 вида сложност.
- Worst-case - данните са подредени по най-лошия за нас начин. Горната граница на алгоритъма
- Average-case - ако всички възможни входни данни ги съберем и ги разделим на броя на входен данни
- Best-case - данните са наредени най-добре за алгоритъма
Интересуват ни worst-case  и average-case
Worst-case ни интересува, когато алгоритъма се изпълнява веднъж. Ключово важно да е бързо.
Average-case - сортиране

Example
=======
Търсене в масив
Worst-case - n сръвнения
Best-case - 1 сръвнение (първия case)
Average-case - n/2 - (n(n+1)/2)/n или (n+1)/2
Работи за линейно време - функция от множеството от функции O(n) (множество от функции, които имат сложност n)

Algorithms Complexity
=====================
Алгоритмична сложност е груба преценка на брой операции които ще са ни нужни спрямо размера на входа
Asymptopic notation O(g) където g е функция на input data size-а
Има операции, които са по бързи от размера на елементите.
Има квадратична стойност, когато се обхождат по n*n брой пъти

Asymptotic Notation
==============
 O(g(n)) = {f(n) : there exist positive constants c and n0 such that f(n) <= c*g(n) for all n>=n0)
 Ако имаме O(n^2) - присъстват всички функции като f(n) и f(2n^2)

Examples
=======
Каква е сложността на функцията която се определя от полинома 3*n^2+n/2+12
Константата я игнорираме. n/2 също игнорираме защото е от по малка степен и остава n^2 - това е сложността
4nlog2(3n+1)+2n-1 E О(n*logn)

Типове сложност
===============
- Constant-на сложност O(1)
  - не зависи от входните параметри - взимане на елемент от масива
- Логаритмичн стойност O(logn)
  - logn операцията означават, че ако имаме алгоритъм с 1000 операции то алгоритъм ще свърши с 2 операции.
  - Ако входа на данните расте линейно, то операциите растат много по бавно
  - binary search, търсене в двоично наредено дърво
- Линейна сложност O(n) - толкова операции, колкото е входа. Търсене в не наредено.
- Полиномиална сложност -
- Квадратична сложност O(n^2)
  - n^2 операции
  - Примера с тъпия начин за намиране на минимален елемент. Всеки елемент го сръвняваме със всички останали.
- Кубична сложност O(n^3) - умножение на матрици,
- nlogn - merge sort, намиране на изпъкнала обвивка в геометрията
- Експоненциялна сложност (O(2^n), O(k^n), O(n!)) - n стъпва в степените
- O(n!) е по-бавно от O(n)

Asymptotic notation example - Big-O complexity

Time and memory complexity
=======================
Може и да е повече от един параметър. Ако работим с матрици или графи
Броя на върхове и броя на ребра O(n+m)

The hidden constant
=================
На практика може да не гледаме само notation-а
Понякога константата също е важна, ако елементите са по малко
Хубаво е да се имат предвид константите.
Пример:
Ако алгоритъм A прави 100*n стъпки, то сложността е O(n)
Алгоритъм B прави n*n/2 стъпки, то сложността е O(n^2)
За n<200, първия ще направи 100*200 = 20000 операции а втория 100*50 = 5000 операции

Real world example
===================
Insertion sort is faster than quicksort for n<=16
Quicksort се използва за по-големи масиви от данни

Polynomial Algorithms
=====================
Полином е математически израз при, който имаме n повдигнато на степен
log(n), 3n^3+4n, 2*nlog(n)

Полиномиалните алгоритми са лесни за изчисление
W(n) принадлежи на O(p(n))

Computational Classes
=====================
P, NP, NP Complete, NP  Hard
P - Свързан ли е графа, Детерминанта на матрица, Умножение на матрици
NP - Онези които не можем да ги изчислим в полиномиално време.
Имаме 3 цвята и трябва да оцветим държавите без две съседни да са едни и същи цветове.
NP Complete - Ако намерим едно решение X, ако можем да намерим решение Y с полиномиално време
NP Hard - Не можем да ги сведем
P ?= NP - 1 milion долара

https://en.wikipedia.org/wiki/Millennium_Prize_Problems

FindInversions  - n^2 - два цикъла

Вложените цикли добавя степента на сложност

Фактуриел с рекурсия е 2^n

Височнина на двоично дърво с n елемента е 2^n-та

Summary
====
- Types of structures
- Complexity of algorithms
